# Mainsail macro configuration
[gcode_macro _CLIENT_VARIABLE]
#variable_use_custom_pos   : False  ; use custom park coordinates for x,y [True/False]
#variable_custom_park_x    : 0.0    ; custom x position; value must be within your defined min and max of X
#variable_custom_park_y    : 0.0    ; custom y position; value must be within your defined min and max of Y
variable_custom_park_dz   : 50.0    ; custom dz value; the value in mm to lift the nozzle when move to park position
#variable_retract          : 0.5    ; the value to retract while PAUSE
#variable_cancel_retract   : 0.5    ; the value to retract while CANCEL_PRINT
#variable_speed_retract    : 35.0   ; retract speed in mm/s
#variable_unretract        : 0.5   ; the value to unretract while RESUME
#variable_speed_unretract  : 35.0   ; unretract speed in mm/s
variable_speed_hop        : 40.0   ; z move speed in mm/s
variable_speed_move       : 250.0  ; move speed in mm/s
variable_park_at_cancel   : True   ; allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
#variable_park_at_cancel_x : None   ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
#variable_park_at_cancel_y : None   ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
variable_use_fw_retract   : True  ; use fw_retraction instead of the manual version [True/False]
variable_idle_timeout     : 300    ; time in sec until idle_timeout kicks in. Value 0 means that no value will be set or restored
variable_runout_sensor    : "filament_switch_sensor filament_switch"    ; If a sensor is defined, it will be used to cancel the execution of RESUME in case no filament is detected.
## !!! Custom macros, please use with care and review the section of the corresponding macro.
## These macros are for simple operations like setting a status LED. Please make sure your macro does not interfere with the basic macro functions.
## Only  single line commands are supported, please create a macro if you need more than one command.
#variable_user_pause_macro : ""    ; Everything inside the "" will be executed after the klipper base pause (PAUSE_BASE) function
#variable_user_resume_macro: ""    ; Everything inside the "" will be executed before the klipper base resume (RESUME_BASE) function
#variable_user_cancel_macro: ""    ; Everything inside the "" will be executed before the klipper base cancel (CANCEL_PRINT_BASE) function
gcode:

[gcode_macro PRINT_START]
description: Called by slicer to setup printer for printing the GCODE file
gcode:
	{% set extruder_temp = params.EXTRUDER_TEMP|float %}
	{% set bed_temp = params.BED_TEMP|default(0.0)|float %}
	{% set chamber_temp = params.CHAMBER_TEMP|default(0.0)|float %}
	{% set mesh_min = params.MESH_MIN %}
	{% set mesh_max = params.MESH_MAX %}
	{% set nozzle_diameter = params.NOZZLE_DIAMETER|float %}
	{action_raise_error("EXTRUDER_TEMP is not set") if not extruder_temp}
	SET_TEMP BED={bed_temp} EXTRUDER={extruder_temp / 2|int} CHAMBER={chamber_temp} ALLOW_ABOVE=1
	TURN_ON_LIGHT
	WAIT_TEMP BED={bed_temp * 0.8} OFFSET=0 ALLOW_ABOVE=1
	LAZY_HOME # Homing after bed_temp * 0.8 has reached to improve Z offset accuracy
	TIMELAPSE_TAKE_FRAME
	WAIT_TEMP BED={bed_temp} EXTRUDER={extruder_temp / 2|int} OFFSET=2 ALLOW_ABOVE=1
	WAIT_TEMP CHAMBER={20 + (chamber_temp - 20) / 2|int} OFFSET=0 ALLOW_ABOVE=1
	PROBE_MESH MESH_MIN={mesh_min} MESH_MAX={mesh_max}
	PARK MOVE_Z=0
	SET_TEMP EXTRUDER={extruder_temp}
	WAIT_TEMP EXTRUDER={extruder_temp}
	WAIT_TEMP BED={bed_temp} OFFSET=3
	{% if mesh_min and mesh_max %}
		PURGE MESH_MIN={mesh_min} MESH_MAX={mesh_max} NOZZLE_DIAMETER={nozzle_diameter}
	{% else %}
		RESPOND MSG="Skipping purge as parameters are missing"
	{% endif %}
	RESPOND MSG="Printing has begun"

[gcode_macro PRINT_END]
description: Called by slicer to end print
gcode:
	TURN_OFF_HEATERS
	M106 S0 # Turn fan off
	MOVE_MIN_HEIGHT MIN_HEIGHT=50
	PARK MOVE_Z=0

[gcode_macro PURGE]
description: Draw purge line, normally used on print start, however also callable without print job to test printer
gcode:
	{% set nozzle_diameter = params.NOZZLE_DIAMETER|default(printer.configfile.settings.extruder.nozzle_diameter)|float %}
	{% set prime_length = params.PRIME_LENGTH|default(30)|int %}
	{% set prime_speed = params.PRIME_SPEED|default(4)|int %}
	{% set wipe_length = params.WIPE_LENGTH|default(10)|int %}
	{% set offset = params.OFFSET|default(3)|int %}
	{% set line_length = prime_length * 4 %}
	{% set purge_length = prime_length + line_length + wipe_length %}
	{% set home_pos = printer.configfile.settings.safe_z_home.home_xy_position %}
	{% set mesh_min = params.MESH_MIN.split(',') if params.MESH_MIN else [home_pos[0] - purge_length / 2, home_pos[1]] %}
	{% set mesh_max = params.MESH_MAX.split(',') if params.MESH_MAX else [home_pos[0] + purge_length / 2, home_pos[1]] %}
	{% set print = {"min": { "x": mesh_min[0]|float, "y": mesh_min[1]|float },
			"max": { "x": mesh_max[0]|float, "y": mesh_max[1]|float }} %}
	{% set width  = (nozzle_diameter * 1.25)|float %}
	{% set prime_width = width * 3 %}
	{% set offset = offset + prime_width / 2 %}
	{% set coords = namespace() %}
	# Check if we can purge at the front
	{% if print.min.y - offset - prime_width > printer.configfile.settings.probe.y_offset %}
		{% set start_x = print.min.x if print.min.x + purge_length < (printer.configfile.settings.bed_mesh.mesh_max[0]|default(0))
				else print.max.x - purge_length if print.max.x - purge_length > (printer.configfile.settings.bed_mesh.mesh_max[0]|default(0))
				else print.min.x + (print.max.x - print.min.x) - purge_length / 2 %}
		{% set coords.purge_start = { "x": start_x,                             "y": print.min.y - offset } %}
		{% set coords.purge_end   = { "x": coords.purge_start.x + prime_length, "y": coords.purge_start.y } %}
		{% set coords.line_end    = { "x": coords.purge_end.x + line_length,    "y": coords.purge_end.y } %}
		{% set coords.wipe_mid    = { "x": coords.line_end.x + wipe_length / 2, "y": coords.line_end.y } %}
		{% set coords.wipe_end    = { "x": coords.wipe_mid.x + wipe_length / 2, "y": coords.wipe_mid.y } %}
	# Check if we can purge at the right
	{% elif print.max.x + offset + prime_width < printer.configfile.settings.bed_mesh.mesh_max[0]|default(0) %}
		{% set start_y = print.min.y if print.min.y + purge_length < (printer.configfile.settings.stepper_y.position_max|default(0))
				else print.max.y - purge_length if print.max.y - purge_length > (printer.configfile.settings.stepper_y.position_max|default(0))
				else print.min.y + (print.max.y - print.min.y) - purge_length / 2 %}
		{% set coords.purge_start = { "x": print.max.x + offset, "y": start_y } %}
		{% set coords.purge_end   = { "x": coords.purge_start.x, "y": coords.purge_start.y + prime_length } %}
		{% set coords.line_end    = { "x": coords.purge_end.x,   "y": coords.purge_end.y + line_length } %}
		{% set coords.wipe_mid    = { "x": coords.line_end.x,    "y": coords.line_end.y + wipe_length / 2 } %}
		{% set coords.wipe_end    = { "x": coords.wipe_mid.x,    "y": coords.wipe_mid.y + wipe_length / 2 } %}
	# Check if we can purge at the left
	{% elif print.min.x - offset - prime_width > 1 %}
		{% set start_y = print.min.y if print.min.y + purge_length < (printer.configfile.settings.stepper_y.position_max|default(0))
				else print.max.y - purge_length if print.max.y - purge_length > (printer.configfile.settings.stepper_y.position_max|default(0))
				else print.min.y + (print.max.y - print.min.y) - purge_length / 2 %}
		{% set coords.purge_start = { "x": print.min.x - offset, "y": start_y } %}
		{% set coords.purge_end   = { "x": coords.purge_start.x, "y": coords.purge_start.y + prime_length } %}
		{% set coords.line_end    = { "x": coords.purge_end.x,   "y": coords.purge_end.y + line_length } %}
		{% set coords.wipe_mid    = { "x": coords.line_end.x,    "y": coords.line_end.y + wipe_length / 2 } %}
		{% set coords.wipe_end    = { "x": coords.wipe_mid.x,    "y": coords.wipe_mid.y + wipe_length / 2 } %}
	# Check if we can purge at the back
	{% elif print.max.y + offset + prime_width < printer.configfile.settings.stepper_y.position_max|default(0) %}
		{% set start_x = print.min.x if print.min.x + purge_length < (printer.configfile.settings.bed_mesh.mesh_max[0]|default(0))
				else print.max.x - purge_length if print.max.x - purge_length > (printer.configfile.settings.bed_mesh.mesh_max[0]|default(0))
				else print.min.x + (print.max.x - print.min.x) - purge_length / 2 %}
		{% set coords.purge_start = { "x": start_x,                             "y": print.max.y + offset  } %}
		{% set coords.purge_end   = { "x": coords.purge_start.x + prime_length, "y": coords.purge_start.y } %}
		{% set coords.line_end    = { "x": coords.purge_end.x + line_length,    "y": coords.purge_end.y } %}
		{% set coords.wipe_mid    = { "x": coords.line_end.x + wipe_length / 2, "y": coords.line_end.y } %}
		{% set coords.wipe_end    = { "x": coords.wipe_mid.x + wipe_length / 2, "y": coords.wipe_mid.y } %}
	{% endif %}
	{% if coords and coords.purge_start %}
		SAVE_GCODE_STATE NAME=purge
		G90
		{% set travel_speed = printer.configfile.settings.stepper_y.homing_speed * 60 %}
		{% set height = (nozzle_diameter * 0.625)|float %}
		G0 Z{printer.configfile.settings.safe_z_home.z_hop} F{printer.configfile.settings.stepper_z.homing_speed * 60} # Move Z Axis up little to prevent scratching of Heat Bed
		G0 X{"%.3f" % (coords.purge_start.x)} Y{"%.3f" % (coords.purge_start.y)} F{travel_speed} # Move to start position
		G0 Z{height} F{printer.configfile.settings.stepper_z.homing_speed * 60}
		# Prime
		DRAW_LINE_TO X={"%.3f" % (coords.purge_end.x)} Y={"%.3f" % (coords.purge_end.y)} HEIGHT={height} WIDTH={prime_width} FEEDRATE={prime_speed * 60}
		# Draw line
		DRAW_LINE_TO X={"%.3f" % (coords.line_end.x)} Y={"%.3f" % (coords.line_end.y)} HEIGHT={height} WIDTH={width} FEEDRATE={travel_speed / 2}
		# Wipe
		{% set user_vars = printer["gcode_macro _CLIENT_VARIABLE"] %}
		G10 # retract
		G0 X{"%.3f" % (coords.wipe_mid.x)} Y{"%.3f" % (coords.wipe_mid.y)} Z{height / 8} F{travel_speed / 2}
		G0 X{"%.3f" % (coords.wipe_end.x)} Y{"%.3f" % (coords.wipe_end.y)} Z{printer.configfile.settings.safe_z_home.z_hop} F{travel_speed / 2}
		G11 # unretract
		G92 E0.0 # Reset Extruder
		RESTORE_GCODE_STATE NAME=purge MOVE=0
	{% else %}
		{action_respond_info("Skipping purge as no free space found")}
	{% endif %}

[gcode_macro DRAW_LINE_TO]
description: Extrudes a line of filament at the specified height and width from
	the current coordinate to the supplied XY coordinate. (The height is used only
	to calculate the extrusion volume.)
gcode:
	{action_raise_error("HEIGHT is not set") if not params.HEIGHT}
	{action_raise_error("WIDTH is not set") if not params.WIDTH}
	{action_raise_error("FEEDRATE is not set") if not params.FEEDRATE}
	{action_raise_error("X is not set") if not params.X}
	{action_raise_error("Y is not set") if not params.Y}
	{% set height = params.HEIGHT|float %}
	{% set width  = params.WIDTH|float %}
	{% set feedrate = params.FEEDRATE|int %}
	{% set x = params.X|float %}
	{% set y = params.Y|float %}
	{% set position = printer.gcode_move.gcode_position %}
	{% set distance = ((x - position.x) ** 2 + (y - position.y) ** 2) ** 0.5 %}
	{% set filament_area = 3.14159 * (printer.configfile.settings.extruder.filament_diameter ** 2) / 4 %}
	{% set extrusion = (distance * width * height) / filament_area %}
	SAVE_GCODE_STATE NAME=draw_line
	G90 # absolute positioning
	G92 E0.0 # temporary reset E axis coords
	G1 X{x} Y{y} F{feedrate} E{"%.3f" % (extrusion)}
	RESTORE_GCODE_STATE NAME=draw_line MOVE=0

[gcode_macro WAIT_TEMP]
description: Wait until set temperatures have settled
gcode:
	{% set bed_temp = params.BED|default(0)|float %}
	{% set extruder_temp = params.EXTRUDER|default(0)|float %}
	{% set chamber_temp  = params.CHAMBER|default(0)|float %}
	{% set offset = params.OFFSET|default(1)|float %}
	{% set allow_above = params.ALLOW_ABOVE|default(False) %}
	{% if bed_temp > 20 %}
		{% if allow_above %}
			{action_respond_info("Waiting for heater_bed to reach atleast %sC" % (bed_temp - offset))}
			TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={bed_temp - offset}
		{% else %}
			{action_respond_info("Waiting for heater_bed to reach %sC~%sC" % (bed_temp - offset, bed_temp + offset))}
			TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={bed_temp - offset} MAXIMUM={bed_temp + offset}
		{% endif %}
	{% endif %}
	{% if chamber_temp > 20 %}
		{% if allow_above %}
			{action_respond_info("Waiting for chamber to reach atleast %sC" % (chamber_temp - offset))}
			TEMPERATURE_WAIT SENSOR="heater_generic chamber" MINIMUM={chamber_temp - offset}
		{% else %}
			{action_respond_info("Waiting for chamber to reach %sC~%sC" % (chamber_temp - offset, chamber_temp + offset))}
			TEMPERATURE_WAIT SENSOR="heater_generic chamber" MINIMUM={chamber_temp - offset} MAXIMUM={chamber_temp + offset}
		{% endif %}
	{% endif %}
	{% if extruder_temp > 20 %}
		{% if allow_above %}
			{action_respond_info("Waiting for extruder to reach atleast %sC" % (extruder_temp-offset))}
			TEMPERATURE_WAIT SENSOR=extruder MINIMUM={extruder_temp - offset}
		{% else %}
			{action_respond_info("Waiting for extruder to reach %sC~%sC" % (extruder_temp-offset, extruder_temp+offset))}
			TEMPERATURE_WAIT SENSOR=extruder MINIMUM={extruder_temp - offset} MAXIMUM={extruder_temp + offset}
		{% endif %}
	{% endif %}

[gcode_macro PROBE_MESH]
description: Level and probe the printer bed
gcode:
	{% set mesh_min = params.MESH_MIN.split(',') if params.MESH_MIN %}
	{% set mesh_max = params.MESH_MAX.split(',') if params.MESH_MAX %}
	{% set print = {"min": { "x": mesh_min[0]|float, "y": mesh_min[1]|float },
			"max": { "x": mesh_max[0]|float, "y": mesh_max[1]|float }} if mesh_min and mesh_max %}
	LAZY_Z_TILT
	# Check if area aleady meshed, if yes skip probing again
	{% set ns = namespace(already_probed=False) %}
	{% if print %}
		{% set bed_mesh = printer.bed_mesh %}
		{% if print.min.x + 1 > bed_mesh.mesh_min[0]
				and print.min.y + 1 > bed_mesh.mesh_min[1]
				and print.max.x - 1 < bed_mesh.mesh_max[0]
				and print.max.y - 1< bed_mesh.mesh_max[1] %}
			{% set ns.already_probed = True %}
			{action_respond_info("Skipping probing as already bed_mesh available")}
		{% endif %}
	{% endif %}
	{% if not ns.already_probed %}
		BED_MESH_CALIBRATE ADAPTIVE=1
	{% endif %}

[gcode_macro SET_TEMP]
description: Set hotend, bed, or chamber to given temperatures
gcode:
	{% set bed_temp = params.BED|default(0)|float %}
	{% set extruder_temp = params.EXTRUDER|default(0)|float %}
	{% set chamber_temp  = params.CHAMBER|default(0)|float %}
	{% if bed_temp > 20 %}
		{action_respond_info("Preheating heater_bed to %sC" % (bed_temp))}
		SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={bed_temp}
	{% endif %}
	{% if extruder_temp > 20 %}
		{action_respond_info("Preheating extruder to %sC" % (extruder_temp))}
		SET_HEATER_TEMPERATURE HEATER=extruder TARGET={extruder_temp}
	{% endif %}
	{% if chamber_temp > 20 %}
		{% if printer.configfile.settings["heater_generic chamber"] %}
			{action_respond_info("Preheating chamber to %sC" % (chamber_temp))}
			SET_HEATER_TEMPERATURE HEATER=chamber TARGET={chamber_temp}
		{% else %}
			{action_respond_info("Heater chamber not defined, ignoring")}
		{% endif %}
	{% endif %}

[gcode_macro LAZY_HOME]
description: Home only axes which are not homed
gcode:
	{% set axes = 'XYZ'|reject('in', printer.toolhead.homed_axes|upper)|join('') %}
	{% if axes %}
		G28{% for k in axes %}{' ' ~ k}{% endfor %}
	{% else %}
		{action_respond_info("Skipping homing as already homed")}
	{% endif %}

[gcode_macro LAZY_Z_TILT]
description: Z tilt only when not done already
gcode:
	{% if not printer.z_tilt.applied %}
		LAZY_HOME
		Z_TILT_ADJUST
	{% else %}
		{action_respond_info("Skipping Z_TILT as already tilted")}
	{% endif %}

[gcode_macro PARK]
description: Park printer, uses mainsail user variables
gcode:
	{% set move_z = params.MOVE_Z|default(True) %}
	##### get mainsail parameters or use default #####
	{% set client = printer["gcode_macro _CLIENT_VARIABLE"]|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set use_custom     = client.use_custom_pos|default(false)|lower == "true" %}
	{% set custom_park_x  = client.custom_park_x|default(0.0) %}
	{% set custom_park_y  = client.custom_park_y|default(0.0) %}
	{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
	{% set sp_hop         = client.speed_hop|default(15) * 60 %}
	{% set sp_move        = client.speed_move|default(velocity) * 60 %}
	##### get config and toolhead values #####
	{% set origin    = printer.gcode_move.homing_origin %}
	{% set act       = printer.gcode_move.gcode_position %}
	{% set max       = printer.toolhead.axis_maximum %}
	##### define park position #####
	{% set z_min = params.Z_MIN|default(0)|float %}
	{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
	{% set x_park = params.X  if params.X is defined
		else (max.x - 5.0) %}
	{% set y_park = params.Y if params.Y is defined
		else custom_park_y  if use_custom
		else (max.y - 5.0) %}
	SAVE_GCODE_STATE NAME=park
	{% set axes = 'XYZ'|reject('in', printer.toolhead.homed_axes|upper)|join('') %}
	{% if axes %}
		LAZY_HOME
	{% endif %}
	G90
	{% if move_z %}
		G1 Z{z_park} F{sp_hop}
	{% endif %}
	G1 X{x_park} Y{y_park} F{sp_move}
	RESTORE_GCODE_STATE NAME=park MOVE=0

[gcode_macro TURN_OFF]
description: Turn printer and the light off
gcode:
	TURN_OFF_LIGHT
	TURN_OFF_PRINTER

[gcode_macro TURN_OFF_PRINTER]
description: Turn off printer circuit (not Raspberry Pi)
gcode: {action_call_remote_method("set_device_power", device="Printer", state="off")}

[delayed_gcode START_WITH_LIGHT]
initial_duration: 3
gcode:
	TURN_ON_LIGHT

[gcode_macro TURN_ON_LIGHT]
description: Turn on printer light
gcode: {action_call_remote_method("set_device_power", device="Light", state="on")}

[gcode_macro TURN_OFF_LIGHT]
description: Turn off printer light
gcode: {action_call_remote_method("set_device_power", device="Light", state="off")}

[gcode_macro HOST_SHUTDOWN]
description: Shutdown whole printer (Raspberry Pi)
gcode: {action_call_remote_method("shutdown_machine")}

[gcode_macro HOST_RESTART]
description: Restart whole printer (Raspberry Pi)
gcode: {action_call_remote_method("reboot_machine")}

[gcode_macro STATE]
description: Get the current idle_timeout state
gcode: {action_respond_info("Printer is currently %s" % (printer.idle_timeout.state))}

[gcode_macro UNSAFE_MOVE]
description: Move axis without homed axes
gcode:
	{% set axis = params.AXIS|default("Z") %}
	{% set offset = params.OFFSET|default(10)|int %}
	{% set z_offset = 0 if axis != "Z" else printer.gcode_move.homing_origin.z %}
	{% set pos = 0 if offset >= 0 else (-offset + -z_offset) %}
	SAVE_GCODE_STATE NAME=unsave_move
	SET_KINEMATIC_POSITION {axis}={pos}
	G91
	G0 {axis}{offset} F600
	M84
	RESTORE_GCODE_STATE NAME=unsave_move MOVE=0

[gcode_macro BEEP]
gcode:
	{% set i = params.I|default(1)|int %}        ; Iterations (number of times to beep).
	{% set dur = params.DUR|default(100)|int %}  ; Duration/wait of each beep in ms. Default 100ms.
	{% for iteration in range(i|int) %}
		SET_PIN PIN=beeper VALUE=1
		G4 P{dur}
		SET_PIN PIN=beeper VALUE=0
		G4 P{dur}
	{% endfor %}

[gcode_macro DUMP_VARIABLES]
gcode:
	{% set filter_name = params.NAME|default('')|string|lower %}
	{% set filter_value = params.VALUE|default('')|string|lower %}
	{% set show_cfg = params.SHOW_CFG|default(0)|int %}
	{% set out = [] %}
	{% for key1 in printer %}
		{% for key2 in printer[key1] %}
			{% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and filter_value in printer[key1][key2]|string|lower %}
				{% set dummy = out.append("printer['%s'].%s = %s" % (key1, key2, printer[key1][key2])) %}
			{% endif %}
		{% else %}
			{% if filter_name in key1|lower and filter_value in printer[key1]|string|lower %}
				{% set dummy = out.append("printer['%s'] = %s" % (key1, printer[key1])) %}
			{% endif %}
		{% endfor %}
	{% endfor %}
    {action_respond_info(out|join("\n"))}

[gcode_macro LOAD_FILAMENT]
variable_load_distance:  60
variable_purge_distance: 30
gcode:
	{% set speed = params.SPEED|default(200) %}
	{% set max_velocity = printer.configfile.settings.extruder.max_extrude_only_velocity * 2 %}
	{% set min_temp = printer.configfile.settings.extruder.min_extrude_temp + 10 %}
	{% set restore_switch = printer["filament_switch_sensor filament_switch"].enabled %}
	{% set restore_motion = printer["filament_motion_sensor filament_motion"].enabled %}
	SAVE_GCODE_STATE NAME=load_filament
	SET_FILAMENT_SENSOR SENSOR=filament_switch ENABLE=0
	SET_FILAMENT_SENSOR SENSOR=filament_motion ENABLE=0
	MOVE_MIN_HEIGHT MIN_HEIGHT=50
	{% if printer.extruder.target < min_temp and printer.extruder.temperature < min_temp %}
		SET_TEMP EXTRUDER={min_temp}
		WAIT_TEMP EXTRUDER={min_temp} OFFSET=0 ALLOW_ABOVE=1
	{% elif printer.extruder.temperature < min_temp %}
		WAIT_TEMP EXTRUDER={printer.extruder.target} ALLOW_ABOVE=1
	{% endif %}
	{action_respond_info("Loading filament")}
	G91
	G92 E0
	G1 E{load_distance} F{max_velocity} # fast-load
	G1 E{purge_distance} F{speed} # purge
	BEEP
	{% if restore_switch %}
		SET_FILAMENT_SENSOR SENSOR=filament_switch ENABLE=1
	{% endif %}
	{% if restore_motion %}
		SET_FILAMENT_SENSOR SENSOR=filament_motion ENABLE=1
	{% endif %}
	RESTORE_GCODE_STATE NAME=load_filament MOVE=0

[gcode_macro UNLOAD_FILAMENT]
variable_unload_distance: 60
variable_purge_distance:  30
gcode:
	{% set max_velocity = printer.configfile.settings.extruder.max_extrude_only_velocity * 2 %}
	{% set min_temp = printer.configfile.settings.extruder.min_extrude_temp + 10 %}
	{% set restore_switch = printer["filament_switch_sensor filament_switch"].enabled %}
	{% set restore_motion = printer["filament_motion_sensor filament_motion"].enabled %}
	SAVE_GCODE_STATE NAME=unload_filament
	SET_FILAMENT_SENSOR SENSOR=filament_switch ENABLE=0
	SET_FILAMENT_SENSOR SENSOR=filament_motion ENABLE=0
	MOVE_MIN_HEIGHT MIN_HEIGHT=50
	{% if printer.extruder.target < min_temp and printer.extruder.temperature < min_temp %}
		SET_TEMP EXTRUDER={min_temp}
		WAIT_TEMP EXTRUDER={min_temp} ALLOW_ABOVE=1
	{% elif printer.extruder.temperature < min_temp %}
		WAIT_TEMP EXTRUDER={printer.extruder.target} ALLOW_ABOVE=1
	{% endif %}
	{action_respond_info("Unloading filament")}
	G91
	G92 E0
	G1 E-{unload_distance} F{max_velocity} # fast-unload
	BEEP
	{% if restore_switch %}
		SET_FILAMENT_SENSOR SENSOR=filament_switch ENABLE=1
	{% endif %}
	{% if restore_motion %}
		SET_FILAMENT_SENSOR SENSOR=filament_motion ENABLE=1
	{% endif %}
	RESTORE_GCODE_STATE NAME=unload_filament MOVE=0

[gcode_macro _FILAMENT_RUNOUT]
description: Called by filament runout sensors
gcode:
	BEEP I=6
	UNLOAD_FILAMENT

[gcode_macro MOVE_MIN_HEIGHT]
description: Moves Z axis to specified height if below
gcode:
	{% set min_height = params.MIN_HEIGHT|default(0)|float %}
	{action_raise_error("Parameter MIN_HEIGHT malformed") if not min_height > 0}
	SAVE_GCODE_STATE NAME=move_min_height
	{% set homed = False if 'XYZ'|reject('in', printer.toolhead.homed_axes|upper)|join('') else True %}
	{% if printer.gcode_move.position[3] <= min_height and homed %}
		G90
		G0 Z{min_height} F{printer.configfile.settings.stepper_z.homing_speed * 60}
	{% endif %}
	RESTORE_GCODE_STATE NAME=move_min_height MOVE=0

[gcode_macro VERIFY_FAN_RPM]
description: Verify that the fans are spinning with the given RPM, if not emergency shutdown
gcode:
	{% set fan = params.FAN|default("heater_fan heatbreak_fan") %}
	{% set min_rpm = params.MIN_RPM|default(2000)|int %}
	{% set heater = params.HEATER %}
	{% set start_fan_temp = params.START_FAN_TEMP|default(50)|int %}
	{% set rpm = printer[fan].rpm %}
	{% if printer.webhooks.state != "shutdown" %}
		{% if rpm is none %}
			{action_raise_error("Fan is not RPM capable: %s" % (fan))}
		{% elif rpm < min_rpm %}
			{% if start_fan_temp and heater %}
				{% set temp = printer[heater].temperature %}
				{% if temp > start_fan_temp %}
					{action_emergency_stop("fan RPM below treshold: %s: %sRPM < %sRPM (%sC > %sC)" % (fan, rpm, min_rpm, temp, start_fan_temp))}
				{% endif %}
			{% else %}
				{action_emergency_stop("fan RPM below treshold: %s: %sRPM < %sRPM" % (fan, rpm, min_rpm))}
			{% endif %}
		{% endif %}
	{% endif %}

[delayed_gcode MONITOR_HEATBREAK_FAN]
initial_duration: 5
gcode:
	VERIFY_FAN_RPM FAN="heater_fan heatbreak_fan" MIN_RPM=3000 START_FAN_TEMP={printer.configfile.settings["heater_fan heatbreak_fan"].heater_temp*1.1} HEATER=extruder
	UPDATE_DELAYED_GCODE ID=MONITOR_HEATBREAK_FAN DURATION=2

[delayed_gcode MONITOR_HOST_FAN]
initial_duration: 5
gcode:
	VERIFY_FAN_RPM FAN="temperature_fan raspberry_pi" MIN_RPM=2500 START_FAN_TEMP={printer.configfile.settings["temperature_fan raspberry_pi"].target_temp*1.2} HEATER="temperature_fan raspberry_pi"
	UPDATE_DELAYED_GCODE ID=MONITOR_HOST_FAN DURATION=2

[delayed_gcode MONITOR_CONTROLLER_FAN]
initial_duration: 10
gcode:
	{% set ns = namespace(stepper_enabled=False) %}
	{% for i in printer['stepper_enable'].steppers.values() %}
		{% set ns.stepper_enabled = (ns.stepper_enabled or i) %}
	{% endfor %}
	{% if ns.stepper_enabled %}
		VERIFY_FAN_RPM FAN="controller_fan controller_fan_left" MIN_RPM=2000 START_FAN_TEMP={printer.configfile.settings["temperature_fan raspberry_pi"].target_temp*1.2} HEATER="temperature_sensor mcu_controller_temp"
		VERIFY_FAN_RPM FAN="controller_fan controller_fan_right" MIN_RPM=2000 START_FAN_TEMP={printer.configfile.settings["temperature_fan raspberry_pi"].target_temp*1.2} HEATER="temperature_sensor mcu_controller_temp"
	{% endif %}
	UPDATE_DELAYED_GCODE ID=MONITOR_CONTROLLER_FAN DURATION=2

[gcode_macro AXIS_CALIBRATE]
description: Start axis calibration, used for calculating rotation_distance. Calculation is done with an extra safety offset of 20mm
gcode:
	{% set axis = params.AXIS|default("E")|string|upper %}
	{% set temp = params.TEMP|default(printer.configfile.settings.extruder.min_extrude_temp + 10)|int %}
	{% set length = params.LENGTH|default(100)|int %}
	{% set offset = params.OFFSET|default(20)|int %}
	{action_raise_error("Invalid axis %s" % (axis)) if axis not in "XYZE"}
	{action_raise_error("Length cannot be smaller than 100mm") if length < 100}
	{action_raise_error("Length %s greater than max_extrude_only_distance" % printer.configfile.settings.extruder.max_extrude_only_distance) if axis == "E" and length > printer.configfile.settings.extruder.max_extrude_only_distance|int}
	{action_respond_info("Calibrating rotation_distance for %s axis, make sure distance of exactly %smm is marked" % (axis, length + offset))}
	{% set restore_switch = printer["filament_switch_sensor filament_switch"].enabled %}
	{% set restore_motion = printer["filament_motion_sensor filament_motion"].enabled %}
	SAVE_GCODE_STATE NAME=axis_calibrate
	SET_FILAMENT_SENSOR SENSOR=filament_switch ENABLE=0
	SET_FILAMENT_SENSOR SENSOR=filament_motion ENABLE=0
	{% if axis == "E" %}
		SET_TEMP EXTRUDER={temp}
		{% set axes = 'XYZ'|reject('in', printer.toolhead.homed_axes|upper)|join('') %}
		{% if axes %}
			LAZY_HOME
		{% endif %}
		MOVE_MIN_HEIGHT MIN_HEIGHT=50
		G92 E0.0 # Reset Extruder
		WAIT_TEMP EXTRUDER={temp} OFFSET=0 ALLOW_ABOVE=1
	{% endif %}
	RESPOND MSG="Moving {axis} axis slowly by {length}mm"
	G91 # relative movement
	G1 {axis}{length} F60
	M400 # wait for movement to complete
	{% if axis == "E" %}
		TURN_OFF_HEATERS
	{% endif %}
	SET_GCODE_VARIABLE MACRO=AXIS_CALC_DISTANCE VARIABLE=length VALUE={length}
	SET_GCODE_VARIABLE MACRO=AXIS_CALC_DISTANCE VARIABLE=axis VALUE="'{axis}'"
	RESPOND MSG="Measure difference from expected {offset}mm offset and enter: AXIS_CALC_DISTANCE DIFF=&lt;measured difference&gt; [AXIS={axis}] [LENGTH={length}]"
	BEEP
	{% if restore_switch %}
		SET_FILAMENT_SENSOR SENSOR=filament_switch ENABLE=1
	{% endif %}
	{% if restore_motion %}
		SET_FILAMENT_SENSOR SENSOR=filament_motion ENABLE=1
	{% endif %}
	RESTORE_GCODE_STATE NAME=axis_calibrate MOVE=0

[gcode_macro AXIS_CALC_DISTANCE]
description: Calculate new rotation_distance
variable_length: 0
variable_axis: "E"
gcode:
	{% set length = params.LENGTH|default(length)|int %}
	{% set axis = params.AXIS|default(axis)|string|upper %}
	{% set diff = params.DIFF|default(0)|float %}
	{% if length > 0 and diff and axis in "XYZE" %}
		{% set old_rotation_distance = printer.configfile.settings.extruder.rotation_distance|float if axis == "E" else
				printer.configfile.settings.stepper_x.rotation_distance|float if axis == "X" else
				printer.configfile.settings.stepper_y.rotation_distance|float if axis == "Y" else
				printer.configfile.settings.stepper_z.rotation_distance|float if axis == "Z" %}
		{% if axis == "Z" and printer.configfile.settings.stepper_z1 %}
			{action_raise_error("Z steppers rotation_distance not in sync") if old_rotation_distance != printer.configfile.settings.stepper_z1.rotation_distance|float}
		{% endif %}
		{% set new_rotation_distance = old_rotation_distance * (length + diff) / length %}
		{action_respond_info("Old stepper %s rotation_distance: %s" % (axis, old_rotation_distance))}
		{action_respond_info("New stepper %s rotation_distance: %s" % (axis, new_rotation_distance))}
	{% else %}
		{action_respond_info("Invalid parameters")}
	{% endif %}
